✅ Rule of Thumb

Interface/Type names (like Task) usually start with a capital letter → they describe the shape of the data.

Variable/Property names (like tasks: Task[]) usually start with lowercase → they hold the actual data.

That’s why this is perfectly fine:

import { Task } from '../models/task.model';

export class AppComponent {
  tasks: Task[] = [];   // ✅ tasks is a list of Task objects
}


Here:

Task → the blueprint (interface).

tasks → an array variable storing multiple objects of type Task.

🚫 Don’t Do This

If you did:

Task: Task[] = [];


TypeScript would complain, because you’re trying to use Task as both a type and a variable name → ambiguity.

✅ Good Naming Convention

Singular for the interface → Task

Plural for the array → tasks

Lowercase singular for one object → task

Example:

task: Task | null = null;   // a single task
tasks: Task[] = [];         // an array of tasks
-----------------------------------------------------------------------------------------------------

@Input() task!: Task | null;
🔎 Break it down
Task
This is the interface we created in task.model.ts.
So task must be of type Task (it should have id, title, description, etc.).

| null (Union Type)
The | symbol means “or” in TypeScript.
So Task | null means:

The variable can either be a Task object or null.

✅ Example:

ts
Copy code
let example: Task | null;

example = { id: 1, title: "Study", description: "Learn Angular" }; // valid (Task)
example = null;  // also valid
Without | null, you’d be forced to always pass a Task, which doesn’t work when nothing is selected yet.
That’s why we allow null → so we can safely show “No task selected” in the UI.

!: (Definite Assignment Assertion)
Normally, TypeScript will complain if you don’t initialize a property right away.
Example:

ts
Copy code
@Input() task: Task | null; // ❌ Error: Property 'task' has no initializer
To tell TypeScript:

“Don’t worry, Angular will assign this later via @Input.”

we use ! like this:

ts
Copy code
@Input() task!: Task | null;
✅ This means “I promise this will be initialized at runtime”.

🚀 Putting it all together
@Input() → Angular decorator: parent passes data to child.

task!: Task | null; →

task can either be Task or null.

! means Angular will assign it later.

So, this line basically says:

👉 “I’m expecting the parent to give me a Task object, but it might also be null (like when nothing is selected). And TypeScript, don’t complain, because Angular will handle the assignment.”

✅ Example in action:

ts
Copy code
// task-detail.component.ts
@Input() task!: Task | null;
html
Copy code
<!-- task-detail.component.html -->
@if (task) {
  <p>{{ task.title }}</p>
} @else {
  <p>No task selected</p>
}
-----------------------------------------------------------------------------------------------------

teach me how filter,find, and push works than u continue with this
ChatGPT said:

Perfect 👌 we’ll pause Angular for a moment and go step by step with JavaScript array methods (filter, find, push) because these are the building blocks you’ll use inside Angular.

🔹 1. push()

👉 Adds a new element to the end of an array.

let tasks = ["Learn Angular", "Build App"];

tasks.push("Review Code");  
console.log(tasks);
// ["Learn Angular", "Build App", "Review Code"]


🔑 Notes:

push changes (mutates) the original array.

Returns the new length of the array.

🔹 2. filter()

👉 Creates a new array with all elements that match a condition.
It does not change the original array.

let numbers = [1, 2, 3, 4, 5, 6];

// get only even numbers
let even = numbers.filter(n => n % 2 === 0);

console.log(even);       // [2, 4, 6]
console.log(numbers);    // [1, 2, 3, 4, 5, 6] (original unchanged)


🔑 Notes:

You get back a new array.

Great for searching subsets (e.g., all "pending" tasks).

🔹 3. find()

👉 Returns the first element that matches a condition.
If nothing matches → returns undefined.

let numbers = [10, 20, 30, 40];

// find first number greater than 25
let result = numbers.find(n => n > 25);

console.log(result);   // 30


🔑 Notes:

Returns only one element (the first match).

If you need all matches, use filter().

🔹 Quick Comparison (Tasks Example)

Imagine we have our Task objects:

let tasks = [
  { id: 1, title: "Learn Angular", status: "pending" },
  { id: 2, title: "Build App", status: "in-progress" },
  { id: 3, title: "Review Project", status: "done" }
];


push()

tasks.push({ id: 4, title: "Deploy App", status: "pending" });


filter() → all "pending" tasks

let pendingTasks = tasks.filter(t => t.status === "pending");
console.log(pendingTasks);
// [
//   { id: 1, title: "Learn Angular", status: "pending" },
//   { id: 4, title: "Deploy App", status: "pending" }
// ]


find() → first "done" task

let doneTask = tasks.find(t => t.status === "done");
console.log(doneTask);
// { id: 3, title: "Review Project", status: "done" }


⚡ So:

push → add

filter → many results (array)

find → single result (first match)
-----------------------------------------------------------------------------------------------------